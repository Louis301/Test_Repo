
--------------------- Теги

Могут интегрироваться в скрипт функцией echo:

echo '<select>';
for ($i = 1; $i <= 10; $i++) {
    echo "<option>$i</option>";
}
echo '</select>';

Выше представлена реализация выпадающего списка из чисел [1; 10].

Тег pre отображает данные в корректном для отладки виде:

echo '<pre>';
print_r($data);
echo '</pre>';

------------------------------ Запуск сервера, общие моменты

<?php  php_code  ?>  - тег даёт понять интерпретатору, какой код надо интерпретировать: HTML or PHP. По умолчанию интерпретируется HTML-код 

php -S localhost:4000  - запускает локальный сервер на хосте localhost (Port 4000)

XAMPP  - дистрибутив Apache для Линукс. 
Open Server  - вариант для Windows.

Скрипт формирует html страницу!

md5, sha1  - функции хэш-шифрования паролей

phpinfo()  - выводит на экран конфигурацию сервера (настройки из файла php.ini)

------------------------------ Переменные

Типы:

bool
string
array
int
float
object  (classes)

Сылочное присваивание:

$c = &$a;  

Выше - присваивание переменной $с 5-ки и привязывание 
переменных $a и $c к одному адресу. Так что при изменении одной переменной
будет меняться другая. 

Модификаторы:

const  - для объявления констант
global  - для объявления глобальных переменных 

------------------------------ Работа с модулями

В случае отсутствия файла, по умолчанию выводятся ошибки.
Настроить вывод можно, изменив параметры функции error_reporting

include 'module.php';  - обработка кода продолжается, если файл module.php не найден
require 'module.php';  - программа прерывается, если файл module.php не найден

include_once 'mod.php';  - проверяет состояние подключения скрипта. Исключает повторное подключение модуля. 
require_once 'mod.php';  - то же самое, только выдаёт фатальную ошибку при отсутствии файла 

ЛУЧШЕ ВСЕГДА ИСПОЛЬЗОВАТЬ require!

------------------------------ Работа со встроенными функциями

echo "Some text", "<br />"  - выводит текст "Some text" на экран и переводит каретку на следующую строку тегом <br />
mt_rand(23, 341)   - возвращает случайное число в диапазоне [23, 341]
unset($var)  - уничтожает переменную
isset($var)  - предикат, если переменная существует (не null)
empty($str)  - предикат, определяет, не пустая ли строка
gettype($var)  - возвращает тип переменной
is_int($var)  - определяет, целым ли числом является переменная (!функция из множества)
settype($str, 'bool')  - явное приведение строковой переменной к логическому типу (возвращает 1 приуспешном преобразовании)
var_dump(var);  - выводит информацию о типе var 
print_r($data)  - вывод данных для отладки

Примеры использования функции header:

header('Content-Type: text/html; charset=utf-8')  - используется для переопределения кодировки. 

header('Location: inc.php');  - перенаправляет на другую страницу, не останавливая обработку скрипта.

header('refresh: 3; url=inc.php');  - перенаправление на другую страницу через 3 секунды. Чтобы последующий код не обрабатывался используется инструкция exit; сразу после header.

------------------------------- Функции работы с датой и временем

int time()  - возвращает кол-во секунд, прошедших с начала эпохи Unix (1970-01-01 00:00:00).

Функция date(): string и её регулярные выражения (первый аргумент). Второй аргумент содержит число секунд отсчитанных от 1970-01-01 00:00:00 (при отсутствии аргумента ставится возврат time()).

$today = date("F j, Y, g:i a");                 // March 10, 2001, 5:16 pm
$today = date("m.d.y");                         // 03.10.01
$today = date("j, n, Y");                       // 10, 3, 2001
$today = date("Ymd");                           // 20010310
$today = date('h-i-s, j-m-y, it is w Day');     // 05-16-18, 10-03-01, 1631 1618 6 Satpm01
$today = date('\i\t \i\s \t\h\e jS \d\a\y.');   // it is the 10th day.
$today = date("D M j G:i:s T Y");               // Sat Mar 10 17:16:18 MST 2001
$today = date('H:m:s \m \i\s\ \m\o\n\t\h');     // 17:03:18 m is month
$today = date("H:i:s");                         // 17:16:18
$today = date("Y-m-d H:i:s");                   // 2001-03-10 17:16:18 (формат MySQL DATETIME)

string date_default_timezone_get()  - возвращает тек. часовой пояс. Например, "Europe/Moscow".

date_default_timezone_set(string)  - принимает значение часового пояса и инициализирует соответствующее поле в файле php.ini 

array getdate()  - возвращает тек. дату в виде массива.

string mktime(date("Y"), date("i"), ...)  - позволяет удобно изменять время

float microtime(true)  - аналог time(), но с миллисекундами.

-------------------------------- Массивы

$array = ['str', true, 7865, false];  - обычный массив
$data = array('str', true, 7865);  - второй способ объявления

Example of associative array:

$mapArray = [
	'str' => 34, 
	true => 27.8, 
	7865 => [2, 19, 2]
];

Обращение к элементам:

echo $array[2];  // 7865
echo $map_array['str'];  // 34

$arr[] = 'newElement';  - добавление элемента в конец массива


    Функции для работы с массивом (Для конкретики смотреть документацию!)

int count($array)  - подсчитывает элементы массива
int count($array, COUNT_RECURSIVE)  - подсчитывает элементы массива во всех измерениях

bool empty($array)  - возвр. 1, если массив пустой

array array_diff(array a1, array a2) - вычисление расхождения массивов. Возвращает те элементы из первого массива, которых НЕТ в остальных массивах.

array array_intersect(array a1, array a2)  - вычисление схождения массивов. Возвращает те элементы из первого массива, которые ЕСТЬ в остальных массивах.

bool array_key_exists($key, $array)  - возвращает 1, если среди ключей массива есть key.

array array_keys($array)  - возврат ключей массива

array array_values($array)  - возврат значений

array array_merge(array a1, array a2)  - объединение массивов с перезаписью значений (если попадаются одинаковые ключи)

array array_rand($array, $count)  - возвращает случайное число или массив чисел. Параметр count - это длина массива. 

array_reverse($data, changeKeys)  - возвращает инвертированный массив (работает с первым измерением). Если changeKeys = 1, инвертирует ключи.

array compact('name', 'surname', 'number')  - формирует массив с ключами, названными как переменные. Ключи связаны со значениями переменных. Функция работает только с ассоциативными массивами.

void extract($array)  - создаёт и инициализирует переменные, одноимённые ключам.
Работает только с ассоциативными массивами.

void arsort($array1);  // по убыванию с сохранением ключей
void sort($array2);  // по возрастанию с изменением ключей
void rsort($array3);  // по убыванию с изменением ключей
void asort($array4);  // по возрастанию с сохранением ключей

array_combine
array_search
array_shift
array_unique
array_unshift
array_flip
array_pop
array_push
in_array
list

-------------------------------- Strings

HEREDOC format:

$text = <<<MY_TEXT
jrekrjht
rekkwkeuuiw
lsekkwl {$someMean}
MY_TEXT;

Concatanation example 1:

$str1 = "Type of ";
$str1 = "data is ";
$data = 3652;
$result = $str1 . $str2;  # . - conc. operator
echo $result, gettype(data);

Concatanation example 2:

 $str = "word {$number}";
$str = "word" . $number;
$str .= 'word';

$data = 'word';  # кавычки одинарные, если данные для подстановки являются строкой
$res = "ggreh {$data}";  

    ФУНКЦИИ ДЛЯ РАБОТЫ СО СТРОКАМИ

string nl2br(text)  - заменяет все строковые литералы '\n' на <br>

string htmlspecialchars(text)  - отображает на экране html-разметку

array explode("|", "word1|word2|word3")  - помещает элементы, разделённые чертой (delimiter) в массив. Разделитель может быть строкой

string implode(' ', $data)  - принимает массив и возвращвет строку из его элементов, разделённых пробелами (агумент 1)

string trim("\n\t   gfjfkdj  \t ")   - удаляет все символы \t, \n, " ", \r с концов строки. При указании доп. параметра (например "\t\n"), функция удалит все эти символы с концов.

string str_replace($search, $replace, $text) (где $search = ['[b]', '[/b]']; $replace = "[b]some text[/b]";)  - принимает текст и заменяет фрагменты текста из первого массива на соответствующие элементы из второго массива.

int strlen($data);  - возвращает длину строки $data (в байтах!)

int mb_strlen($data, 'utf-8')  - многобайтовая функция (работает с разными кодировками, возвращая корректный результат).

string strip_tags($text, '<b>');  - оставляет в переменной text только теги, перечисленные во втором параметре.

int mb_strpos("Слово", 'о');  - возвращает позицию начала строки (арг2) в основном тексте (арг1). При указании арг3 (позиции начала поиска) поиск идёт с этого указанного индекса включительно!

string mb_strtoupper($string);  - перевод в верхний регистр 
string mb_strtolower($string);  - перевод в нижний регистр

string substr($text, 3, 5)  - возвр. фрагмент строки. Например, для "word woRd worD" выведет d woR (третьего включительно, 5 значащих элементов). Замыкающие пробелы удаляются.

--------------------------------- Математические функции

round($number, 2);  # 2 - количество знаков после запятой. Округление числа: 467.97865 -> 467.98

ceil($number);  # округляет до следующего целого: 45.98 -> 46
floor($number); # отбрасывает дробную часть: 4657.786 -> 4657

decbin(int: num) string  # 3 -> "11"
bindec(string: binNum) int  # "111" -> "11"

--------------------------------- ООП

- Объявление класса содержится в одном файле (заголовочном), а код, исп-щий класс - в другом. Подключается заголовочный файл инструкцией include_once 'file_name.php' или require_once.

Пример класса с сеттерами, геттерами, статическими методами и модификаторами доступа:

class Point
{
    private $_x, $_y = 34;  # поля можно инициализировать
    private static $variable = 14;  

    public function setX($x) { $this->_x = $x; }  # $this-> используется для работы с полями ОБЪЕКТОВ
    public function setY($y) { $this->_y = $y; }
    
    public function getX() { return $this->_x; }
    public function getY() { return $this->_y; }

    public static function getStaticVar()
    {
        return self::$variable;  # self:: используется для работы со статикой
    }
}

Пример работы с классом:

$point = new Point();  # init object
$point->setX("word_word");  # вызов сеттера
echo $point->getX() . "\n";  # вызов метода объекта point
echo $point->getY() . "\n";
echo Point::getStaticVar() . "\n";  # вызов статического метода

-------------------------------- Цикл foreach

Всегда выводит ЗНАЧЕНИЯ массива (Пример 1)!

Пример 1:

foreach ($data as $item) {
    echo $item . '<br>';
}

Пример 2:

foreach ($data as $key => $value) {
    echo "key: $key, value: $value \n";
}

Следовательно, $key => $value является элементом ($item).
Следующая конструкция изменяет входные данные по ссылке. 

foreach($arr as &$value)  // аналог  for(auto &elem : data){}
{
    $value += 3;
}

--------------------------------- Альтернативные конструкции

Ниже показан разрыв php-кода с помощью альт. констр. для удобства написания html.
При print == true, таблица печатается.

<?php if($print): ?>  // ':' заменяет '{'
    <table>
        <tr>
            <td><?php echo $var1; ?></td>  // вызов переменной var1, объявленной в предыдущей части php
            <td><?php echo $var2; ?></td>
            <td><?php echo $var3; ?></td>
        </tr>
    </table>
<?php endif; ?>  // 'endif;' заменяет '}'

При if закрывающая инструкция - endif;
При foreach закрывающая инструкция - endforeach;
При while закрывающая инструкция - endwhile;

--------------------------------- Пользовательские функции

function func($a, $b, $c = 5)  // $с - параметр по умолчанию, можно менять при вызове
{
    echo "Sum = " . $a + $b . "<br>";
}

function func(&$data) {}   // Передача аргумента по ссылке (всё, как в С++)

--------------------------------- Суперглобальные переменные

$_SERVER - масив данных о текущем сервере
$_GET  - массив данных, принятых из формы методом get 
$_POST  - массив данных, принятых из формы методом post
$_FILES - массив переданных файлов
$_SESSION  - данные сессии

--------------------------------- Сессии

Сессия - это временный файл, существующий до закрытия браузера. Хранится на сервере 

session_start()  - создаёт сессию
session_unset()  - очищает поля сессии
session_destroy()  - удаляет сессию (файл)
session_id()  - возвращает номер сессии, идентичный имени файла сессии

Поля сессии хранятся в массиве _SESSION 

--------------------------------- Функции работы с файлами

void copy('file.txt', 'folder/file_copy.txt');  - копируем файл из первой (арг1) директории во вторую (арг2).
 
bool file_exists(path);  - проверка существование файла по адресу path

string file_get_contents(path);  - принимает данные из файла по адресу path и возвращает их в виде текста. Может обращаться к файлам по url и считывать html-код страниц

void file_put_contents(path1, path2)  - записывает данные из источника (арг2) в файл (арг1). Метод записи определяется флагами (арг3)

array file(path, FLAG)  - последовательно записывает каждую строку файла (path) в ячейки одномерного массива

is_dir(path), is_file(path)  - предикаты, определяющие, каталог ли или файл находится по указанному пути

bool move_uploaded_file (path1)  - перемещение загруженных данных ($_FILES) по указанному пути

mkdir(path)  - создаёт папку по указанному пути. Может использовать флаги для рекурсивного создания папки

rmdir(path)  - удаление папки

unlink(path)  - удаление файла

------------------------------- Работа с SQL

mysqli_connect('localhost', 'root', 'root', 'gb') - создание объекта соединения с базой. Арг1 - домен, арг4 - имя базы. Останые - логин.пароль к базе

mysqli_connect_error())  - выводит сообщение об ошибках соединения

mysqli_query($db, $insert)  - применяет запрос (арг2) к базе, указанной в объекте соединения (арг1). Возвращает 0 в случае ошибки

mysqli_error($db)  - отображает подробности ошибок запроса

mysqli_affected_rows($db)  - возвращает 0, если изменений таблицы (записей) не происходило, -1 - если были ошибки. Иначе возвращает количество изменённых строк

$data = mysqli_fetch_all(mysqli_query($bd, $select))  - принимает результат запроса выборки данных из базы (select) и записывает в массив $data. Атрибут MYSQLI_ASSOC делает массив ассоциативным

$str = mysqli_real_escape_string($db, $str)  - экранирует поле str для запроса